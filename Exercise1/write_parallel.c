/* ///////////////////////////////////////////////////////////////////// */
/*! 
  \file  
  \brief Writing of a 1D buffer in parallel.

  Write a 1D buffer in parallel using 4 different versions.
  For a contiguous data type, use:

  VERSION == 1 employs shared file pointer
  VERSION == 2 employs individual file pointer with offset computed
               by the MPI_File_seek()
  VERSION == 3 defines a file view with offset depending on the process
               rank
  VERSION == 4 similar to VERSION == 3, but using a contiguous MPI
               datatype

  A non-contiguous version is handled with VERSION == 5, which defines
  a MPI vector datatype and a file view.
   
  \author A. Mignone (mignone@to.infn.it)
  \date   March 1, 2020

  #if VERSION == 1     // Contiguous data, shared file pointer
  MPI_File_write_ordered(fh, buf, NELEM, MPI_DOUBLE, MPI_STATUS_IGNORE);  
#elif VERSION == 2   // Contiguous data, individual file pointer
  disp = rank*NELEM*sizeof(double);   // In bytes
  MPI_File_seek(fh, disp, MPI_SEEK_SET);
  MPI_File_write(fh, buf, NELEM, MPI_DOUBLE, MPI_STATUS_IGNORE);


  #elif VERSION == 4   // Contiguous data, file view with MPI datatype
  MPI_Datatype cntg_type;

  MPI_Type_contiguous(NELEM, MPI_DOUBLE, &cntg_type);
  MPI_Type_commit(&cntg_type);

  disp = rank*NELEM*sizeof(double);

  MPI_File_set_view(fh, disp, MPI_BYTE, cntg_type, "native", MPI_INFO_NULL);
  MPI_File_write(fh, buf, 1, cntg_type, MPI_STATUS_IGNORE);  
  MPI_Type_free(&cntg_type);
#elif VERSION == 5   // Non-contiguous data, file view, vector type
  MPI_Datatype vec_type;

  for (i = 0; i < NELEM; i++) buf[i] = rank + 0.1*i;

  MPI_Type_vector(NELEM, 1, size, MPI_DOUBLE, &vec_type);
  MPI_Type_commit(&vec_type);

  disp = rank*sizeof(double);
  MPI_File_set_view(fh, disp, MPI_DOUBLE, vec_type, "native", MPI_INFO_NULL);
  MPI_File_write(fh, buf, NELEM, MPI_DOUBLE, MPI_STATUS_IGNORE);  
  MPI_Type_free(&vec_type);
#endif

*/
/* ///////////////////////////////////////////////////////////////////// */
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <mpi.h>

#define NELEM    3

void read_pgm_image( unsigned char **image, int *maxval, int *xsize, int *ysize, const char *image_name);

int main(int argc, char **argv)
{
  int i, rank, size;
  double buf[NELEM];
  char fname[] = "arr1D.pgm";
  MPI_File   fh;
  MPI_Offset disp;

/* --------------------------------------------------------
   0. Initialize the MPI execution environment
   -------------------------------------------------------- */

  MPI_Init (&argc, &argv);
  MPI_Comm_rank (MPI_COMM_WORLD, &rank);
  MPI_Comm_size (MPI_COMM_WORLD, &size);

/* --------------------------------------------------------
   1. Initialize array
   -------------------------------------------------------- */

  for (i = 0; i < NELEM; i++) buf[i] = 255;

/* --------------------------------------------------------
   2. Delete, re-open file and write
   -------------------------------------------------------- */

  MPI_File_delete(fname, MPI_INFO_NULL);
  MPI_File_open(  MPI_COMM_WORLD, fname, 
                  MPI_MODE_CREATE | MPI_MODE_RDWR, 
                  MPI_INFO_NULL, &fh  );

  // Initialize PGM file Header
  // fprintf(image_file, "P5\n# generated by\n# Elena Rivaroli and Samuele D'Avenia\n%d %d\n%d\n", xsize, ysize, maxval);
  if (rank == 0) {
    printf("Process %d is doing it\n", rank);
    FILE* file_stream = fopen(fname, "w");  // Open a FILE* stream
    int xsize, ysize, maxval;
    xsize = 10;
    ysize = 10;
    maxval = 255;
    if (file_stream != NULL) {
      int max_value = size - 1;
      fprintf(file_stream, "P5\n# generated by\n# Elena Rivaroli and Samuele D'Avenia\n%d %d\n%d\n", xsize, ysize, maxval);
      fclose(file_stream);
    } else {
      fprintf(stderr, "Failed to open the PGM file for writing.\n");
      MPI_Abort(MPI_COMM_WORLD, 1);
    }
  }
  MPI_Barrier(MPI_COMM_WORLD);



// Contiguous data, file view
  disp = rank*NELEM*sizeof(double);
  MPI_File_set_view(fh, disp, MPI_DOUBLE, MPI_DOUBLE, "native", MPI_INFO_NULL);
  MPI_File_write(fh, buf, NELEM, MPI_DOUBLE, MPI_STATUS_IGNORE);  

  MPI_File_close(&fh);
  MPI_Finalize();
  return 0;
}



void read_pgm_image( unsigned char **image, int *maxval, int *xsize, int *ysize, const char *image_name)
/*
 * image        : a pointer to the pointer that will contain the image
 * maxval       : a pointer to the int that will store the maximum intensity in the image
 * xsize, ysize : pointers to the x and y sizes
 * image_name   : the name of the file to be read
 *
 */
/*
"image" is a pointer to a pointer so:
- with *image I access the address of the first element of the string (image)
- with **image I access the value of the first element of the string (image)
*/
{
  FILE* image_file; 
  image_file = fopen(image_name, "r");

  *image = NULL; //address of the first element of image
  *xsize = *ysize = *maxval = 0; // set to 0 the value of xsize, ysize and maxval
  
  char    MagicN[2]; // define a string of 2 elements
  char   *line = NULL; //define a pointer "line" to NULL
  size_t  k, n = 0;
  
  // get the Magic Number
  k = fscanf(image_file, "%2s%*c", MagicN );

  // skip all the comments
  k = getline( &line, &n, image_file);
  while ( (k > 0) && (line[0]=='#') )
    k = getline( &line, &n, image_file);

  if (k > 0)
    {
      k = sscanf(line, "%d%*c%d%*c%d%*c", xsize, ysize, maxval);
      if ( k < 3 )
	fscanf(image_file, "%d%*c", maxval);
    }
  else
    {
      *maxval = -1;         // this is the signal that there was an I/O error
			    // while reading the image header
      free( line );
      return;
    }
  free( line );
  
  int color_depth = 1 + ( *maxval > 255 );
  unsigned int size = *xsize * *ysize * color_depth;
  
  if ( (*image = (unsigned char*)malloc( size )) == NULL )
    {
      fclose(image_file);
      *maxval = -2;         // this is the signal that memory was insufficient
      *xsize  = 0;
      *ysize  = 0;
      return;
    }
  
  if ( fread( *image, 1, size, image_file) != size )
    {
      free( image );
      image   = NULL;
      *maxval = -3;         // this is the signal that there was an i/o error
      *xsize  = 0;
      *ysize  = 0;
    }  
/*
  for (int u = 0; u < 9; u++) {
    //printf("%u\t", (*image)[u]);
    printf("%u\t", *(*image+u));
  }
*/
  printf("\n");
  
  fclose(image_file);
  return;
}