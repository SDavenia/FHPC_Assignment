/* ///////////////////////////////////////////////////////////////////// */
/*! 
  \file  
  \brief Writing of a 1D buffer in parallel.

  Write a 1D buffer in parallel using 4 different versions.
  For a contiguous data type, use:

  VERSION == 1 employs shared file pointer
  VERSION == 2 employs individual file pointer with offset computed
               by the MPI_File_seek()
  VERSION == 3 defines a file view with offset depending on the process
               rank
  VERSION == 4 similar to VERSION == 3, but using a contiguous MPI
               datatype

  A non-contiguous version is handled with VERSION == 5, which defines
  a MPI vector datatype and a file view.
   
  \author A. Mignone (mignone@to.infn.it)
  \date   March 1, 2020
*/
/* ///////////////////////////////////////////////////////////////////// */
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <mpi.h>
#include <time.h>
#include <omp.h>

#define NELEM 400000000

int main(int argc, char **argv)
{
  int i, rank, size;
  int k = 20000;
  char fname[] = "arr1D.pgm";
  MPI_File   fh;
  MPI_Offset disp;

/* --------------------------------------------------------
   0. Initialize the MPI execution environment
   -------------------------------------------------------- */

  MPI_Init (&argc, &argv);
  MPI_Comm_rank (MPI_COMM_WORLD, &rank);
  MPI_Comm_size (MPI_COMM_WORLD, &size);

/* --------------------------------------------------------
   1. Initialize array
   -------------------------------------------------------- */
  unsigned char* buf;
  buf = (unsigned char*)malloc((NELEM/size)*sizeof(unsigned char));
  for (i = 0; i < (NELEM)/size; i++) buf[i] = rank;

/* --------------------------------------------------------
   2. Delete, re-open file and write
   -------------------------------------------------------- */
    double Tstart_write;
    if(rank == 0) 
        Tstart_write = omp_get_wtime();

  MPI_Request request;

  MPI_File_delete(fname, MPI_INFO_NULL);
  MPI_File_open(  MPI_COMM_WORLD, fname, 
                  MPI_MODE_CREATE | MPI_MODE_RDWR, 
                  MPI_INFO_NULL, &fh  );

    if (rank == 0) {
    FILE* file_stream = fopen(fname, "w");  // Open a FILE* stream
    /*int xsize, ysize, maxval;
    xsize = k;
    ysize = k;
    maxval = 255;*/

    if (file_stream != NULL) {
        int max_value = size - 1;
        fprintf(file_stream, "P5\n# generated by\n# Elena Rivaroli and Samuele D'Avenia\n%d %d\n%d\n", k, k, 255);
        fclose(file_stream);
    }
    }

  MPI_Barrier(MPI_COMM_WORLD); // Wait for the header to have finished writing.

  disp = rank*(NELEM/size)*sizeof(double)+72;   // In bytes

  MPI_File_seek(fh, disp, MPI_SEEK_SET);
  MPI_File_iwrite_all(fh, buf,(NELEM/size), MPI_UNSIGNED_CHAR, &request);

  MPI_Wait(&request, MPI_STATUS_IGNORE);
  MPI_File_close(&fh);
    MPI_Barrier(MPI_COMM_WORLD);
    if(rank == 0){
        double Time_write = omp_get_wtime() - Tstart_write;
        printf("Write time: %lf\n", Time_write);
    }


  MPI_Finalize();
  return 0;
}
