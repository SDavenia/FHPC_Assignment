#define _GNU_SOURCE // sched_getcpu(3) is glibc-specific (see the man page)

#include <stdio.h>
#include <stdlib.h>
#include <omp.h>
#include <mpi.h>
#include <time.h>
#include <sched.h> // Needed to find out which core each thread is running on


// #define CPU_TIME (clock_gettime( CLOCK_PROCESS_CPUTIME_ID, &ts ), (double)ts.tv_sec + (double)ts.tv_nsec * 1e-9)
// To compile on mac /usr/local/bin/gcc-12 -fopenmp 

/*
 The matrix will be initialised in parallel, but for now for writing it to file that will
 be done in serial, since there are additional complications for doing that.

 N.B.
 If you use a shared seed this will create seed contention issues among the threads, leading to the code not scaling at all.
 In this case the seed is initialised to the time, and then to ensure it is different among threads, each one of them is added its thread it.
*/

int main(int argc, char* argv[])
{
    int k; // Matrix size
    if (argc > 1)
        k = atoi(argv[1]);
    else
        k = 5;
    //printf("Initialising matrix of size %d\n", k);

    int rank, size;
    MPI_Init( &argc, &argv );
    MPI_Comm_rank( MPI_COMM_WORLD,&rank );
    MPI_Comm_size( MPI_COMM_WORLD,&size );  

    // Defines how many rows each process has to initialise
    int rows_initialize = k / size; 
    if (rank < k%size) // For remainder 
        rows_initialize += 1;

    char fname[] = "init.pgm";
    MPI_File fh;
    MPI_Offset disp;

    // printf( "I am %d of %d and I have to generate %d rows\n", rank, size, rows_initialize);

    unsigned char* ptr = (unsigned char*)calloc(rows_initialize*k, sizeof(unsigned char)); // Allocate memory for the rows you have to generate.
    
    double Tstart_init = omp_get_wtime();
    #pragma omp parallel
    {
        int my_id = omp_get_thread_num();
        int cpu_num = sched_getcpu(); // To see what core it is using
        unsigned int seed = clock();
        seed += my_id;
        // printf("I am thread %d of process %d and I am running on core %d\n", my_id, rank, cpu_num);

        #pragma omp for
        for (int i = 0; i < rows_initialize*k; i++){
            unsigned char random_num = (unsigned char) rand_r(&seed) % 2;
            //printf("random_num is %d\n", random_num);
            ptr[i] = random_num==1 ? 255 : 0;
        }

    }
    
    double Time_init = omp_get_wtime() - Tstart_init;
    printf("I am %d and generating random matrix took %lf s\n",rank, Time_init);

   /*
    char fname2[] = "prova.txt";
  // Open a FILE* stream
    MPI_Barrier(MPI_COMM_WORLD);
    if(rank == 0){
        FILE* prova_file = fopen(fname2, "w");
        fprintf(prova_file,"I am process %d\n", rank);
        for(int i =0; i<k*rows_initialize;i++){
            fprintf(prova_file,"%u ", ptr[i]);
        }
        fclose(prova_file);
    }
    printf("\n");

    MPI_Barrier(MPI_COMM_WORLD);
    if(rank == 1){
        FILE* prova_file = fopen(fname2, "a");
        fprintf(prova_file,"I am process %d\n", rank);
        for(int i =0; i<k*rows_initialize;i++){
            fprintf(prova_file,"%u ", ptr[i]);
        }
        fclose(prova_file);
    }
    printf("\n");
   */

    MPI_File_delete(fname, MPI_INFO_NULL);
    MPI_File_open(  MPI_COMM_WORLD, fname, 
                  MPI_MODE_CREATE | MPI_MODE_RDWR, 
                  MPI_INFO_NULL, &fh  );
    MPI_File_close(&fh);

    if (rank == 0) {
        FILE* file_stream = fopen(fname, "w");  // Open a FILE* stream
        int xsize, ysize, maxval;
        xsize = k;
        ysize = k;
        maxval = 255;

        if (file_stream != NULL) {
            int max_value = size - 1;
            fprintf(file_stream, "P5\n# generated by\n# Elena Rivaroli and Samuele D'Avenia\n%d %d\n%d\n", xsize, ysize, maxval);
            fclose(file_stream);
        } else {
            fprintf(stderr, "Failed to open the PGM file for writing.\n");
            MPI_Abort(MPI_COMM_WORLD, 1);
        }
    }

    MPI_Barrier(MPI_COMM_WORLD);
    MPI_File_open(MPI_COMM_WORLD, fname, 
                  MPI_MODE_APPEND | MPI_MODE_RDWR, 
                  MPI_INFO_NULL, &fh  );
    
    if (rank >= k % size)
        rows_initialize += k % size;

    disp = rank * rows_initialize * k *sizeof(unsigned char);
    MPI_File_seek(fh, disp, MPI_SEEK_CUR);
    MPI_File_write_all(fh, ptr, rows_initialize*k, MPI_UNSIGNED_CHAR, MPI_STATUS_IGNORE);

    MPI_File_close(&fh);

    free(ptr);
    MPI_Finalize();
    
}

